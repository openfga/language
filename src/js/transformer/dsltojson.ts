import OpenFGAListener from "../gen/OpenFGAListener";
import { AuthorizationModel, RelationMetadata, RelationReference, TypeDefinition, Userset } from "@openfga/sdk";
import * as antlr from "antlr4";
import OpenFGALexer from "../gen/OpenFGALexer";
import OpenFGAParser, {
  RelationDeclarationContext, RelationDefDirectAssignmentContext,
  RelationDefPartialAllAndContext,
  RelationDefPartialAllButNotContext,
  RelationDefPartialAllOrContext,
  RelationDefRelationOnRelatedObjectContext,
  RelationDefRelationOnSameObjectContext,
  RelationDefTypeRestrictionContext,
  SchemaVersionContext,
  TypeDefContext, TypeDefsContext,
} from "../gen/OpenFGAParser";

enum RelationDefinitionOperator {
  RELATION_DEFINITION_OPERATOR_NONE = "",
  RELATION_DEFINITION_OPERATOR_OR = "or",
  RELATION_DEFINITION_OPERATOR_AND = "and",
  RELATION_DEFINITION_OPERATOR_BUT_NOT = "but not",
}

type RelationTypeInfo = RelationMetadata;

interface Relation {
  name: string;
  rewrites: Userset[];
  operator: RelationDefinitionOperator;
  typeInfo: RelationTypeInfo;
}

/**
 * This Visitor walks the tree generated by parsers and produces Python code
 *
 * @returns {object}
 */
class Listener extends OpenFGAListener {
  public authorizationModel: Partial<AuthorizationModel> = {};
  private currentTypeDef: Partial<TypeDefinition> | undefined;
  private currentRelation: Partial<Relation> | undefined;

  exitSchemaVersion = (ctx: SchemaVersionContext) => {
    this.authorizationModel.schema_version = ctx.getText();
  };

  enterTypeDefs = (ctx: TypeDefsContext) => {
    this.authorizationModel.type_definitions = [];
  };

  exitTypeDefs = (ctx: TypeDefsContext) => {
    if (!this.authorizationModel.type_definitions?.length) {
      delete this.authorizationModel.type_definitions
    }
  };

  enterTypeDef = (ctx: TypeDefContext) => {
    this.currentTypeDef = {
      relations: {},
      metadata: { relations: {} },
    };
  };

  exitTypeDef = (ctx: TypeDefContext) => {
    this.currentTypeDef!.type = ctx.typeName().getText();

    if (!Object.keys(this.currentTypeDef?.metadata?.relations || {}).length) {
      this.currentTypeDef!.metadata = null as any;
    }

    this.authorizationModel.type_definitions?.push(this.currentTypeDef as TypeDefinition);
    this.currentTypeDef = undefined;
  };

  enterRelationDeclaration = (ctx: RelationDeclarationContext) => {
    this.currentRelation = {
      rewrites: [],
      typeInfo: { directly_related_user_types: [] },
    };
  };

  exitRelationDeclaration = (ctx: RelationDeclarationContext) => {
    const relationName = ctx.relationName().getText();
    let relationDef: Userset | undefined;
    const rewrites = this.currentRelation?.rewrites;
    if (rewrites?.length === 1) {
      relationDef = rewrites[0];
    } else {
      if (this.currentRelation?.operator === RelationDefinitionOperator.RELATION_DEFINITION_OPERATOR_OR) {
        relationDef = {
          union: {
            child: rewrites,
          },
        };
      } else if (this.currentRelation?.operator === RelationDefinitionOperator.RELATION_DEFINITION_OPERATOR_AND) {
        relationDef = {
          intersection: {
            child: rewrites,
          },
        };
      } else if (this.currentRelation?.operator === RelationDefinitionOperator.RELATION_DEFINITION_OPERATOR_BUT_NOT) {
        relationDef = {
          difference: {
            base: rewrites![0],
            subtract: rewrites![1],
          },
        };
      }
    }
    if (relationDef) {
      this.currentTypeDef!.relations![relationName] = relationDef;
      const directlyRelatedUserTypes = this.currentRelation?.typeInfo?.directly_related_user_types;
      if (directlyRelatedUserTypes?.length) {
        this.currentTypeDef!.metadata!.relations![relationName] = { directly_related_user_types: directlyRelatedUserTypes };
      } else {
        this.currentTypeDef!.metadata!.relations![relationName] = { directly_related_user_types: [] };
      }
    }

    this.currentRelation = undefined;
  };


  enterRelationDefDirectAssignment = (ctx: RelationDefDirectAssignmentContext) => {
    this.currentRelation!.typeInfo = { directly_related_user_types: [] };
  };
  exitRelationDefDirectAssignment = (ctx: RelationDefDirectAssignmentContext) => {
    const partialRewrite: Userset = {
      this: {},
    };
    this.currentRelation?.rewrites?.push(partialRewrite);
  };
  exitRelationDefTypeRestriction = (ctx: RelationDefTypeRestrictionContext) => {
    const relationRef: Partial<RelationReference> = {};
    const type = ctx.relationDefTypeRestrictionType();

    const usersetRestriction = ctx.relationDefTypeRestrictionUserset();
    const wildcardRestriction = ctx.relationDefTypeRestrictionWildcard();
    if (type) {
      relationRef.type = type.getText();
    }
    if (usersetRestriction) {
      relationRef.type = usersetRestriction.relationDefTypeRestrictionType().getText();
      relationRef.relation = usersetRestriction.relationDefTypeRestrictionRelation().getText();
    }
    if (wildcardRestriction) {
      relationRef.type = wildcardRestriction.relationDefTypeRestrictionType().getText();
      relationRef.wildcard = {};
    }
    this.currentRelation!.typeInfo!.directly_related_user_types!.push(relationRef as RelationReference);
  };

  exitRelationDefRelationOnSameObject = (ctx: RelationDefRelationOnSameObjectContext) => {
    const partialRewrite: Userset = {
      computedUserset: {
        object: "",
        relation: ctx.rewriteComputedusersetName().getText(),
      },
    };
    this.currentRelation?.rewrites?.push(partialRewrite);
  };

  exitRelationDefRelationOnRelatedObject = (ctx: RelationDefRelationOnRelatedObjectContext) => {
    const partialRewrite: Userset = {
      tupleToUserset: {
        computedUserset: {
          object: "",
          relation: ctx.rewriteTuplesetComputedusersetName().getText(),
        },
        tupleset: {
          object: "",
          relation: ctx.rewriteTuplesetName().getText(),
        },
      },
    };
    this.currentRelation?.rewrites?.push(partialRewrite);
  };

  enterRelationDefPartialAllOr = (ctx: RelationDefPartialAllOrContext) => {
    this.currentRelation!.operator = RelationDefinitionOperator.RELATION_DEFINITION_OPERATOR_OR;
  };
  enterRelationDefPartialAllAnd = (ctx: RelationDefPartialAllAndContext) => {
    this.currentRelation!.operator = RelationDefinitionOperator.RELATION_DEFINITION_OPERATOR_AND;
  };
  enterRelationDefPartialAllButNot = (ctx: RelationDefPartialAllButNotContext) => {
    this.currentRelation!.operator = RelationDefinitionOperator.RELATION_DEFINITION_OPERATOR_BUT_NOT;
  };
}

/**
   *
   * @param {string} dsl
   * @returns {string}
   */
export default function transformDslToJSON(dsl: string): AuthorizationModel {
    const is = new antlr.InputStream(dsl);

    // Create the Lexer
    const lexer = new OpenFGALexer(is as antlr.CharStream);
    const stream = new antlr.CommonTokenStream(lexer);

    // Create the Parser
    const parser = new OpenFGAParser(stream);

    // Finally parse the expression
    const listener = new Listener();
    new antlr.ParseTreeWalker().walk(listener, parser.main());

    return listener.authorizationModel as AuthorizationModel;

}